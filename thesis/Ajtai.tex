\section{Ajtai's Average to Worst-case Hardness Connection}

%\todo{Looked everywhere, WebOfScience, GoogleScholar, Bibus, etc... Cannot find more than the extended abstract. There is an email two actually on the abstract: ajtai@almaden.ibm.com and ftpmail@ftp.eccc.uni-trier.de instructions for second email \begin{quotation} subject: help eccc \end{quotation}. Not sure if I should email; not sure email is even a good one. The abstract gives a proof sketch which is very good, but how can I check it without the full paper if I try to do it?}

\todo{Asked the Math librarian}


In nearly every \emph{classical} cryptographic construction the object is as follows:
\newline
\begin{itemize}
	\item Generate a specific instance of a problem and it's solution in the complexity class NP\footnote{NP is the computational complexity class of non-determininistic polynomial time algorithms, elaborated upon further on in this section.},
	\item such that it is reasonable to conclude the problem is \begin{quotation} hard to solve \end{quotation} for some reason; where \begin{quotation} hard to solve \end{quotation} is meant in the worst-case.
\end{itemize}
The usual example of this type of problem is RSA and it's related problem \emph{Integer Factorization}. 

\medskip
\todo{use a different example. Perhaps discrete log and ecc. This one is so over done}

\bigskip
\textbf{Example:} \emph{Integer Factorization and RSA}
\newline

\todo{fix pseudocode box}
%\begin{center}
%\fbox{%\pseudocode[linenumbering,syntaxhighlight=auto]
\newline
\todo{change to caption}
\textbf{RSA Pseudocode Example}
\bigskip

The security of RSA in the above example depends on the fact that neither $p$ nor $q$ will be approximately $\sqrt{N}$. But this is not the only way for $p$ and $q$ to create a \emph{weak} composite ($N$). It turns out that not all composites are equally hard to break into their respective prime factors. In fact, not only are there primes of many different forms of prime that will always, (even just sometimes, unexpectedly) create composite integers that will be efficiently and easily factorable; moreover, we don't even know all the ways primes can create \emph{weaker} composites. If don't know all the forms of primes which will make these types of easily decomposable numbers, we can't even test for them. We want to believe these problems are hard to solve, but despite our best efforts we have no evidence that they really are. For instance, we would like to believe that RSA is \emph{at least as hard to solve} as the integer factorization problem, but we have no proof that this is true. 
\newline
So how do we get away with assuming that integer factorization being hard, is at all a reasonable assumption to make?
\medskip

Even more, didn't we say that the statement \begin{quotation} hard to solve \end{quotation} meant in the worst-case instance?!
\newline
In reality, many cryptographers have hoped choosing (or not choosing) primes of a certain type would ensure that $N$ would be hard to factor and failed horribly at doing so. None chose their forms of primes arbitrarily, they all seemed to make reasonable choices for primes to keep in or leave out; it didn't matter, more weak composites kept popping up in unexpected and annoying ways. 
\newline

\subsection*{There are infinitly many primes...}

We have three areas of computational complexity, the first is self-explanitory it is the \emph{best-case} instance of a problem. The uninteresting, set of instances made under the best of conditions, where everything goes as planned. The second two are what will be of more interest, they are the \emph{average-case} and \emph{worst-case} instances of a problem. 
\bigskip
    
\subsubsection*{Average-case Complexity}

The average-case set of instances of a problem are the ones which usually apply to problems we are more familiar with, integer factorization, discrete logarithms, and other problems in which we are only able to \emph{assume} are hard to solve. We do have hope that our hardness assumptions are still reasonable and these lie in two sets of problems for non-deterministic\footnote{We call an algorithm non-deterministic if given a repeat output it does not return the same solution it gave us the last time gave it as input.} algorithms. The first of these two classes is the set of $NP-complete$ problems.
\medskip

{defn}
{$NP-Complete$}
{Given a decision problem $\mathcal{P}_{d}$ such that $\mathcal{P}_{d}$ is considered hard to solve, then $\mathcal{P}_{d}$ is an element of $NPC$.}
\medskip

This means we have group all the problems that even have the slightest possible chance of being called hard problems into one set called $NPC$. 

\medskip
